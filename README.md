# custom-16bit-cpu
Designed and simulated a custom 16-bit CPU to explore computer architecture fundamentals, including instruction set design, control logic, and datapath execution. Built and tested in Logisim Evolution

# Custom 16-bit CPU

## Project Status
This project is currently in active development. The instruction set architecture and high-level datapath design have been defined, and implementation of core components such as the ALU, register file, and control unit is ongoing in Logisim Evolution. This repository will be updated as additional components are completed and tested.

## Progress

### Design
- [x] Define project goals and motivation
- [x] Outline high-level CPU architecture
- [x] Decide on instruction width (16-bit)
- [ ] Define register count and layout (R0â€“R7)
- [ ] Lock instruction formats (R-type / I-type)
- [ ] Assign opcode bit patterns for each instruction

### Implementation
- [x] Build Register File subcircuit
- [ ] Build ALU subcircuit
- [ ] Build Program Counter
- [ ] Build Instruction Memory
- [ ] Build Data Memory
- [ ] Design and implement Control Unit
- [ ] Integrate full datapath (single-cycle CPU)

## Register File

- 8 registers, 16 bits each
- Dual read ports (rs, rt)
- Single write port (rd, write_data)
- Synchronous clock (clk)
- Tested using manual sanity checks in Logisim

<img src="docs/register_file_diagram.png" width="500">

### Testing
- [ ] Write test programs for arithmetic operations
- [ ] Write test programs for memory operations (LOAD / STORE)
- [ ] Write test programs for control flow (BEQ / JMP)
- [ ] Verify correctness in simulation
- [ ] Debug edge cases and control signal issues

### Documentation & Reflection
- [x] Write initial README with design overview
- [ ] Update README with ISA specifications
- [ ] Add diagrams (datapath, ALU, register file)
- [ ] Add screenshots of Logisim simulation
- [ ] Write analysis and reflection of challenges and design choices

## Overview
This project documents the design and simulation of a custom 16-bit CPU to understand how instructions are executed on a hardware level. The CPU will be implemented in Logisim Evolution and will support a basic instruction set for arithmetic, memory access, and control flow.

## Motivation
The motivation for this project is the understand computer architecure on a deeper level through personal experience, rather than only learning concepts theoretically. Through hands-on design, I can connect low level hardware concepts with how software instructions are executed.

## Architecture
The CPU will consist of several core components, including an ALU, register file, program counter, control unit, instruction memory, and memory modules. The ALU receives instructions from the register file and executes operations based on signals generated by the control unit. The program counter holds the address for the next instruction to be executed which is then decoded by the control unit, coordinating the behavior of the CPU. The instruction memory stores the instructions executed by the CPU and the data memory stores operations during program execution. Together, these components implement the fetch-decode-execute cycle. 

## Instruction Set
The CPU will use a custom 16-bit instruction set designed to support basic arithmetic, memory access, and control flow. Instructions will be divided into R-type and I-type formats, allowing operations between registers as well as immediate values and memory addresses.

### Instruction Table

| Instruction | Type   | Description |
|------------|--------|-------------|
| ADD  | R-type | Adds two registers |
| SUB  | R-type | Subtracts registers |
| AND  | R-type | Bitwise AND |
| OR   | R-type | Bitwise OR |
| LOAD | I-type | Load from memory |
| STORE| I-type | Store to memory |
| BEQ  | I-type | Branch if equal |
| JMP  | I-type | Jump |

### Design Rationale
This instruction set is intentionally kept small to simplify control logic while still supporting programs such as loops and conditional branches. Separating instructions into R-type and I-type formats will reduce decoding complexity and will make the CPU easier to extend in future iterations.

## Implementation
The CPU is being implemented in Logisim Evolution using modular subcircuits for each major component. Each subsystem will be designed independently before being integrated into the full datapath. Logisim Evolution was chosen because it allows low-level visualization of signal flow and clocked behavior, making it well-suited for understanding CPU operation at the hardware level.

## Testing
Correctness will be verified using a variety of hand written test programs loaded into instruction memory. These tests will validate arithmetic operations, memory access instructions, and control flow behavior such as conditional branching and jumps. Simulation based testing in Logisim will allow inspection of register values, memory contents, and control signals to ensure the CPU behaves as intended. Additional tests will be added as new instructions are implemented.

## Analysis & Reflection
This project emphasizes clarity and correctness over performance, leading to design choices such as a small instruction set and a simple control structure. Anticipated challenges include control unit design and debugging complex datapath interactions. Future improvements may include pipelining, an expanded instruction set, or implementing a simple assembler to translate assembly programs into machine code.
