# custom-16bit-cpu
Designed and simulated a custom 16-bit CPU to explore computer architecture fundamentals, including instruction set design, control logic, and datapath execution. Built and tested in Logisim Evolution

# Custom 16-bit CPU

## Project Status
This project is currently in active development. The instruction set architecture and high-level datapath design have been defined, and implementation of core components such as the ALU, register file, and control unit is ongoing in Logisim Evolution. This repository will be updated as additional components are completed and tested.

## Overview
This project documents the design and simulation of a custom 16-bit CPU to understand how instructions are executed on a hardware level. The CPU will be implemented in Logisim Evolution and will support a basic instruction set for arithmetic, memory access, and control flow.

## Motivation
The motivation for this project is the understand computer architecure on a deeper level through personal experience, rather than only learning concepts theoretically. Through hands-on design, I can connect low level hardware concepts with how software instructions are executed.

## Architecture
The CPU will consist of several core components, including an ALU, register file, program counter, control unit, instruction memory, and memory modules. The ALU receives instructions from the register file and executes operations based on signals generated by the control unit. The program counter holds the address for the next instruction to be executed which is then decoded by the control unit, coordinating the behavior of the CPU. The instruction memory stores the instructions executed by the CPU and the data memory stores operations during program execution. Together, these components implement the fetch-decode-execute cycle. 

## Instruction Set
The CPU will use a custom 16-bit instruction set designed to support basic arithmetic, memory access, and control flow. Instructions will be divided into R-type and I-type formats, allowing operations between registers as well as immediate values and memory addresses.

### Instruction Table
Instruction |   Type    | Description
ADD         |  R-type |   Adds two registers and stores the result in a destination register

SUB         |  R-type |   Subtracts one register from another
AND         |  R-type |   Performs bitwise AND on two registers
OR          |  R-type |   Performs bitwise OR on two registers
LOAD        |  I-type |   Loads a value from memory into a register
STORE       |  I-type |   Stores a register value into memory
BEQ         |  I-type |   Branches if two registers are equal
JMP         |  I-type |   Jumps to a specified instruction address

### Design Rationale
This instruction set is intentionally kept small to simplify control logic while still supporting programs such as loops and conditional branches. Separating instructions into R-type and I-type formats will reduce decoding complexity and will make the CPU easier to extend in future iterations.

## Implementation
The CPU is being implemented in Logisim Evolution using modular subcircuits for each major component. Each subsystem will be designed independently before being integrated into the full datapath. Logisim Evolution was chosen because it allows low-level visualization of signal flow and clocked behavior, making it well-suited for understanding CPU operation at the hardware level.

## Testing
Correctness will be verified using a variety of hand written test programs loaded into instruction memory. These tests will validate arithmetic operations, memory access instructions, and control flow behavior such as conditional branching and jumps. Simulation based testing in Logisim will allow inspection of register values, memory contents, and control signals to ensure the CPU behaves as intended. Additional tests will be added as new instructions are implemented.

## Analysis & Reflection
This project emphasizes clarity and correctness over performance, leading to design choices such as a small instruction set and a simple control structure. Anticipated challenges include control unit design and debugging complex datapath interactions. Future improvements may include pipelining, an expanded instruction set, or implementing a simple assembler to translate assembly programs into machine code.
